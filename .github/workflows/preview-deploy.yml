set -euo pipefail
die() { echo "❌ $1"; exit 1; }
run() { echo "▶ $*"; "$@"; }

# show failing command on errors
trap 'echo "❌ FAIL at line $LINENO: $BASH_COMMAND (exit=$?)"' ERR

echo "SHELL=$SHELL"
echo "BASH_VERSION=${BASH_VERSION:-none}"
echo "0=$0"

PR_NUMBER="${PR_NUMBER:-16}"
PR_SHA="${PR_SHA:-542f9569afcf99a32fe433fef12cdda37eb85849}"

PREVIEW_BASE_HOST="linuxtest2.woki.co.il"
PR_PATH="/pr/${PR_NUMBER}"

APP_DIR="/opt/apps/yardena-previews/pr-${PR_NUMBER}"
REPO_SSH="git@github.com:ValeryDevWoki/CI-CD_Testing.git"
PROJECT="yardena-pr-${PR_NUMBER}"

MAIN_DB_CONTAINER="yardena-db-1"
PGUSER="yardena"
PGDATABASE="yardena_test"

DUMP_DIR="$APP_DIR/.cache/db-dumps"
DUMP_FILE="$DUMP_DIR/latest.dump"
LOCK_FILE="/tmp/yardena_dump.lock"
DUMP_MAX_AGE_MINUTES=60

COMPOSE_FILE="$APP_DIR/deploy/docker-compose.preview.yml"

echo "ENV CHECK: PR_NUMBER=$PR_NUMBER PREVIEW_BASE_HOST=$PREVIEW_BASE_HOST PR_PATH=$PR_PATH"
echo "APP_DIR=$APP_DIR PROJECT=$PROJECT"
echo "COMPOSE_FILE=$COMPOSE_FILE"

echo "STEP: check docker access"
docker ps >/dev/null

echo "STEP: prepare APP_DIR"
mkdir -p "$APP_DIR"

if [ ! -d "$APP_DIR/.git" ]; then
  echo "STEP: clone repo"
  git clone "$REPO_SSH" "$APP_DIR"
fi

echo "STEP: checkout PR SHA"
cd "$APP_DIR"
git fetch --all
git reset --hard "$PR_SHA"

# backend.env copy
if [ ! -f "$APP_DIR/deploy/backend.env" ]; then
  if [ -f "/opt/apps/yardena/deploy/backend.env" ]; then
    echo "STEP: copy backend.env from main"
    cp /opt/apps/yardena/deploy/backend.env "$APP_DIR/deploy/backend.env"
  else
    die "Missing deploy/backend.env and /opt/apps/yardena/deploy/backend.env not found"
  fi
fi

echo "STEP: prepare dump dir: $DUMP_DIR"
mkdir -p "$DUMP_DIR"

echo "STEP: acquire lock (flock, 120s): $LOCK_FILE"
(
  flock -w 120 9 || die "Could not acquire lock in time: $LOCK_FILE"
  echo "✅ Lock acquired: $LOCK_FILE"

  echo "================ DB DIAGNOSTICS (pre-up) ================"
  run date
  run whoami
  run pwd

  echo "---- Docker overview (top containers) ----"
  run docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}" || true

  echo "---- MAIN DB container check ----"
  echo "MAIN_DB_CONTAINER=$MAIN_DB_CONTAINER"
  MAIN_CID="$(docker ps -qf "name=^${MAIN_DB_CONTAINER}$" | head -n1 || true)"
  [ -n "${MAIN_CID:-}" ] || die "Main DB container not running: $MAIN_DB_CONTAINER"
  echo "MAIN_CID=$MAIN_CID"

  echo "Main DB readiness:"
  run docker exec "$MAIN_CID" pg_isready -U "$PGUSER" -d "$PGDATABASE" -h 127.0.0.1 || true

  echo "Main DB can connect?"
  run docker exec "$MAIN_CID" psql -U "$PGUSER" -d "$PGDATABASE" -c \
    "select now() as now, current_database() as db, current_user as usr;" || true

  echo "Main DB tables count (sanity):"
  run docker exec "$MAIN_CID" psql -U "$PGUSER" -d "$PGDATABASE" -tAc \
    "select count(*) from pg_tables where schemaname not in ('pg_catalog','information_schema');" || true

  echo "================ END DIAGNOSTICS (pre-up) ================"

  # Decide whether to use cached dump
  NEED_DUMP=1
  if [ -f "$DUMP_FILE" ]; then
    # file age in minutes
    AGE_MIN=$(( ( $(date +%s) - $(stat -c %Y "$DUMP_FILE") ) / 60 ))
    echo "Dump cache exists: $DUMP_FILE (age=${AGE_MIN}m)"
    if [ "$AGE_MIN" -lt "$DUMP_MAX_AGE_MINUTES" ]; then
      NEED_DUMP=0
      echo "✅ Using cached dump (age < ${DUMP_MAX_AGE_MINUTES}m)"
    fi
  fi

  if [ "$NEED_DUMP" -eq 1 ]; then
    echo "STEP: create fresh dump from main DB -> $DUMP_FILE"
    TMP_DUMP="${DUMP_FILE}.tmp"
    rm -f "$TMP_DUMP"
    run docker exec "$MAIN_CID" pg_dump -U "$PGUSER" -d "$PGDATABASE" -Fc > "$TMP_DUMP"
    mv "$TMP_DUMP" "$DUMP_FILE"
    echo "✅ Dump saved: $DUMP_FILE"
    run ls -lah "$DUMP_FILE" || true
  fi
) 9>"$LOCK_FILE"

echo "STEP: ensure compose file exists"
[ -f "$COMPOSE_FILE" ] || die "Compose file not found: $COMPOSE_FILE"

echo "STEP: bring down preview stack and remove volumes"
run docker compose -p "$PROJECT" -f "$COMPOSE_FILE" down -v --remove-orphans || true

echo "STEP: build + up preview stack"
run docker compose -p "$PROJECT" -f "$COMPOSE_FILE" up -d --build --force-recreate --remove-orphans

echo "STEP: locate PR DB container id"
PR_DB_CID="$(docker compose -p "$PROJECT" -f "$COMPOSE_FILE" ps -q db | head -n1 || true)"
[ -n "${PR_DB_CID:-}" ] || die "Could not find PR DB container id (service: db)"
echo "PR_DB_CID=$PR_DB_CID"

echo "STEP: wait for PR Postgres readiness (up to 120s)"
for i in $(seq 1 120); do
  if docker exec "$PR_DB_CID" pg_isready -U "$PGUSER" -d "$PGDATABASE" -h 127.0.0.1 >/dev/null 2>&1; then
    echo "✅ PR Postgres is ready"
    break
  fi
  if [ "$i" -eq 120 ]; then
    echo "PR DB logs (last 200 lines):"
    docker logs --tail 200 "$PR_DB_CID" || true
    die "PR Postgres did not become ready in time"
  fi
  sleep 1
done

echo "STEP: restore dump into PR DB (clean/if-exists/no-owner/no-privileges)"
[ -f "$DUMP_FILE" ] || die "Dump file missing: $DUMP_FILE"

# Use cat -> docker exec -i to feed dump into pg_restore
cat "$DUMP_FILE" | docker exec -i "$PR_DB_CID" pg_restore \
  -U "$PGUSER" -d "$PGDATABASE" \
  --clean --if-exists --no-owner --no-privileges

echo "✅ Restore done"

echo "STEP: print preview URL"
echo "✅ Preview URL: https://${PREVIEW_BASE_HOST}${PR_PATH}/"
echo "✅ API URL:     https://${PREVIEW_BASE_HOST}${PR_PATH}/api/"